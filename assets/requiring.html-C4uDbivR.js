import{_ as a,e as o,g as i,f as d,h as t,i as r,j as s,r as l,o as c}from"./app-Mt0-3WUT.js";const p={};function h(u,e){const n=l("RouteLink");return c(),o("div",null,[e[5]||(e[5]=i("h1",{id:"跨插件访问",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#跨插件访问"},[i("span",null,"跨插件访问")])],-1)),i("p",null,[e[2]||(e[2]=t("NoneBot 插件化系统的设计使得插件之间可以功能独立、各司其职，我们可以更好地维护和扩展插件。但是，有时候我们可能需要在不同插件之间调用功能。NoneBot 生态中就有一类插件，它们专为其他插件提供功能支持，如：")),r(n,{to:"/version-2.4.0/best-practice/scheduler.html"},{default:s(()=>e[0]||(e[0]=[t("定时任务插件")])),_:1}),e[3]||(e[3]=t("、")),r(n,{to:"/version-2.4.0/best-practice/data-storing.html"},{default:s(()=>e[1]||(e[1]=[t("数据存储插件")])),_:1}),e[4]||(e[4]=t("等。这时候我们就需要在插件之间进行跨插件访问。"))]),e[6]||(e[6]=d(`<h2 id="插件跟踪" tabindex="-1"><a class="header-anchor" href="#插件跟踪"><span>插件跟踪</span></a></h2><p>由于 NoneBot 插件系统通过 <a href="https://docs.python.org/3/reference/import.html#import-hooks" target="_blank" rel="noopener noreferrer">Import Hooks</a> 的方式实现插件加载与跟踪管理，因此我们<strong>不能</strong>在 NoneBot 跟踪插件前进行模块 import，这会导致插件加载失败。即，我们不能在使用 NoneBot 提供的加载插件方法前，直接使用 <code>import</code> 语句导入插件。</p><p>对于在项目目录下的插件，我们通常直接使用 <code>load_from_toml</code> 等方法一次性加载所有插件。由于这些插件已经被声明，即便插件导入顺序不同，NoneBot 也能正确跟踪插件。此时，我们不需要对跨插件访问进行特殊处理。但当我们使用了外部插件，如果没有事先声明或加载插件，NoneBot 并不会将其当作插件进行跟踪，可能会出现意料之外的错误出现。</p><p>简单来说，我们必须在 <code>import</code> 外部插件之前，确保依赖的外部插件已经被声明或加载。</p><h2 id="插件依赖声明" tabindex="-1"><a class="header-anchor" href="#插件依赖声明"><span>插件依赖声明</span></a></h2><p>NoneBot 提供了一种方法来确保我们依赖的插件已经被正确加载，即使用 <code>require</code> 函数。通过 <code>require</code> 函数，我们可以在当前插件中声明依赖的插件，NoneBot 会在加载当前插件时，检查依赖的插件是否已经被加载，如果没有，会尝试优先加载依赖的插件。</p><p>假设我们有一个插件 <code>a</code> 依赖于插件 <code>b</code>，我们可以在插件 <code>a</code> 中使用 <code>require</code> 函数声明其依赖于插件 <code>b</code>：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nonebot </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> require</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">require</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;b&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> some_function</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>require</code> 函数的参数为插件索引名称或者外部插件的模块名称。在完成依赖声明后，我们可以在插件 <code>a</code> 中直接导入插件 <code>b</code> 所提供的功能。</p>`,9))])}const m=a(p,[["render",h],["__file","requiring.html.vue"]]),k=JSON.parse('{"path":"/version-2.4.0/advanced/requiring.html","title":"跨插件访问","lang":"zh-CN","frontmatter":{"sidebar_position":4,"description":"使用其他插件提供的功能","options":{"menu":[{"category":"advanced","weight":50}]},"head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/nonebot2/version-2.4.0/advanced/requiring.html"}],["meta",{"property":"og:site_name","content":"nonebot2"}],["meta",{"property":"og:title","content":"跨插件访问"}],["meta",{"property":"og:description","content":"使用其他插件提供的功能"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"跨插件访问\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/nonebot2/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.05,"words":614},"filePathRelative":"version-2.4.0/advanced/requiring.md","excerpt":"\\n<p>NoneBot 插件化系统的设计使得插件之间可以功能独立、各司其职，我们可以更好地维护和扩展插件。但是，有时候我们可能需要在不同插件之间调用功能。NoneBot 生态中就有一类插件，它们专为其他插件提供功能支持，如：<a href=\\"/nonebot2/version-2.4.0/best-practice/scheduler.html\\" target=\\"_blank\\">定时任务插件</a>、<a href=\\"/nonebot2/version-2.4.0/best-practice/data-storing.html\\" target=\\"_blank\\">数据存储插件</a>等。这时候我们就需要在插件之间进行跨插件访问。</p>","bioChainData":{"outlink":[{"title":"scheduler","link":"version-2.4.0/best-practice/scheduler.html"},{"title":"data-storing","link":"version-2.4.0/best-practice/data-storing.html"}],"backlink":[{"title":"data-storing","link":"version-2.4.0/best-practice/data-storing.html"},{"title":"scheduler","link":"version-2.4.0/best-practice/scheduler.html"},{"title":"create-plugin","link":"version-2.4.0/tutorial/create-plugin.html"}],"localMap":{"nodes":[{"id":"version-2.4.0/advanced/requiring.md","value":{"title":"requiring","path":"version-2.4.0/advanced/requiring.md","outlink":["version-2.4.0/best-practice/scheduler.md","version-2.4.0/best-practice/data-storing.md"],"backlink":["version-2.4.0/best-practice/data-storing.md","version-2.4.0/best-practice/scheduler.md","version-2.4.0/tutorial/create-plugin.md"]}},{"id":"version-2.4.0/best-practice/scheduler.md","value":{"title":"scheduler","path":"version-2.4.0/best-practice/scheduler.md","outlink":[],"backlink":[]}},{"id":"version-2.4.0/best-practice/data-storing.md","value":{"title":"data-storing","path":"version-2.4.0/best-practice/data-storing.md","outlink":[],"backlink":[]}},{"id":"version-2.4.0/tutorial/create-plugin.md","value":{"title":"create-plugin","path":"version-2.4.0/tutorial/create-plugin.md","outlink":[],"backlink":[]}}],"links":[{"source":"version-2.4.0/advanced/requiring.md","target":"version-2.4.0/best-practice/scheduler.md"},{"source":"version-2.4.0/advanced/requiring.md","target":"version-2.4.0/best-practice/data-storing.md"},{"source":"version-2.4.0/best-practice/data-storing.md","target":"version-2.4.0/advanced/requiring.md"},{"source":"version-2.4.0/best-practice/scheduler.md","target":"version-2.4.0/advanced/requiring.md"},{"source":"version-2.4.0/tutorial/create-plugin.md","target":"version-2.4.0/advanced/requiring.md"}]}}}');export{m as comp,k as data};
